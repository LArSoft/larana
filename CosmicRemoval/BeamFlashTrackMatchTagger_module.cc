////////////////////////////////////////////////////////////////////////
// Class:       BeamFlashTrackMatchTagger
// Module Type: producer
// File:        BeamFlashTrackMatchTagger_module.cc
// Author:      Wes Ketchum, based on code from Ben Jones
// 
// Description: Module that compares all tracks to the flash during the 
//              beam gate, and determines if that track is consistent with
//              having produced that flash.
// Input:       recob::OpFlash, recob::Track
// Output:      anab::CosmicTag (and Assn<anab::CosmicTag,recob::Track>)
//
// Generated at Sat Aug 16 15:57:53 2014 by Wesley Ketchum using artmod
// from cetpkgsupport v1_06_02.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDProducer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

#include <memory>

#include "Utilities/AssociationUtil.h"
#include "BeamFlashTrackMatchTaggerAlg.h"

namespace cosmic {
  class BeamFlashTrackMatchTagger;
}

class cosmic::BeamFlashTrackMatchTagger : public art::EDProducer {
public:
  explicit BeamFlashTrackMatchTagger(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  BeamFlashTrackMatchTagger(BeamFlashTrackMatchTagger const &) = delete;
  BeamFlashTrackMatchTagger(BeamFlashTrackMatchTagger &&) = delete;
  BeamFlashTrackMatchTagger & operator = (BeamFlashTrackMatchTagger const &) = delete;
  BeamFlashTrackMatchTagger & operator = (BeamFlashTrackMatchTagger &&) = delete;
  void reconfigure(fhicl::ParameterSet const& p);
  void produce(art::Event & e) override;


private:

  // Declare member data here.
  BeamFlashTrackMatchTaggerAlg fAlg;
  std::string fTrackModuleLabel;
  std::string fFlashModuleLabel;

};


cosmic::BeamFlashTrackMatchTagger::BeamFlashTrackMatchTagger(fhicl::ParameterSet const & p)
  : fAlg(p.get<fhicl::ParameterSet>("BeamFlashTrackMatchAlgParams")),
    fTrackModuleLabel(p.get<std::string>("TrackModuleLabel")),
    fFlashModuleLabel(p.get<std::string>("FlashModuleLabel"))
{
  produces< std::vector<anab::CosmicTag> >();
  produces< art::Assns<recob::Track, anab::CosmicTag> >();
}

void cosmic::BeamFlashTrackMatchTagger::reconfigure(fhicl::ParameterSet const& p){
  fhicl::ParameterSet alg_params = p.get<fhicl::ParameterSet>("BeamFlashTrackMatchAlgParams");
  fAlg.reconfigure(alg_params);

  fTrackModuleLabel = p.get<std::string>("TrackModuleLabel");   
  fFlashModuleLabel = p.get<std::string>("FlashModuleLabel");
}

void cosmic::BeamFlashTrackMatchTagger::produce(art::Event & evt)
{
  //services we'll be using
  art::ServiceHandle<geo::Geometry> geomHandle;
  geo::Geometry const& geom(*geomHandle);
  art::ServiceHandle<phot::PhotonVisibilityService> pvsHandle;
  phot::PhotonVisibilityService const& pvs(*pvsHandle);

  //Get Flashes from event.
  art::Handle< std::vector<recob::OpFlash> > flashHandle;
  evt.getByLabel(fFlashModuleLabel, flashHandle);
  std::vector<recob::OpFlash> const& flashVector(*flashHandle);

  //Get Tracks from event.
  art::Handle< std::vector<recob::Track> > trackHandle;
  evt.getByLabel(fTrackModuleLabel, trackHandle);
  std::vector<recob::Track> const& trackVector(*trackHandle);

  //Make the containger for the tag product to put onto the event.
  std::unique_ptr< std::vector<anab::CosmicTag> > cosmicTagPtr ( new std::vector<anab::CosmicTag>);
  std::vector<anab::CosmicTag> & cosmicTagVector(*cosmicTagPtr);
  
  //Make a container for the track<-->tag associations. 
  //One entry per cosmic tag, with entry equal to index in track collection of associated track.
  std::vector<size_t> assnTrackTagVector;
  std::unique_ptr< art::Assns<recob::Track,anab::CosmicTag> > assnTrackTag(new art::Assns<recob::Track,anab::CosmicTag>);
  
  //reserve space for as many tags as tracks. May or may not be that big.
  cosmicTagVector.reserve(trackVector.size());
  assnTrackTagVector.reserve(trackVector.size());

  //run the alg!
  fAlg.RunCompatibilityCheck(flashVector, trackVector, 
			     cosmicTagVector, assnTrackTagVector,
			     geom, pvs);


  //Make the associations for ART
  for(size_t assn_iter=0; assn_iter<assnTrackTagVector.size(); assn_iter++){
    art::Ptr<recob::Track> trk_ptr(trackHandle,assnTrackTagVector[assn_iter]);
    util::CreateAssn(*this, evt, cosmicTagVector, trk_ptr, *assnTrackTag, assn_iter); 
  }

  //put the data on the event
  evt.put(std::move(cosmicTagPtr));
  evt.put(std::move(assnTrackTag));

}

DEFINE_ART_MODULE(cosmic::BeamFlashTrackMatchTagger)
